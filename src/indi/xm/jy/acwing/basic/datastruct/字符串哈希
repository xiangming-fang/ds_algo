字符串哈希：字符串前缀哈希

要点：
1、字符串中的每个字符都看成一个数字(Askii码对应数值)，这个数字是 P 进制的。
eg: ABCDEF = A * p^5 + B * p^4 + C * p^3 + D * p^2 + E * p^1 + F * p^0
由于字符串哈希计算的结果可能会很大，所以我们需要将其对一个具体数字取模，这里用 Q = Long.MAX_VALUE
（因为java里的整数结构都是有正负情况的，不存在无符号整数类型，所以我们不能用溢出来表示取模结果）

2、P 这个数经验值是 131 或者 13331 是为了减少哈希冲突的可能。

3、字符串哈希的有可能产生冲突，但是我们只要用我们的经验值 P = 131 或者13331，那么不产生哈希冲突的可能性约等于99.99%
（再加上我们的字符串哈希的绝对人品：那就是100%不会冲突，哈哈。）

4、为什么我们需要预处理字符串前缀哈希？

因为这样我们可以计算出这个字符串中任意一段子串的哈希值。

eg：字符串 s = ABCDEF，求出[4,5]子串的哈希值？
我们可以知道[4,5]子串表示的字符串是：EF，我们是可以直接取出具体子串，然后用 转进制的求法:
EF = E * P^1 + F * P^0
但是如果问的次数非常多 或者 子串非常大的话那这个方法显然不适合，时间复杂度急剧升高！！！

[4,5] 区间问题，自然而然就想到了类似前缀和的思想，所以需要计算字符串对应的前缀哈希。

我们看看具体怎么操作？

用一个数组long[] 为了后续计算前缀和统一格式，我们从第一个位置开始存储字符串对应的第0个位置字符哈希值。

long[0]  => 0
long[1]  => 前一个字符的哈希
long[2]  => 前两个字符的哈希
long[3]  => 前三个字符的哈希

前i个字符的哈希值是：(以字符串遍历顺序为主）
long[i+1] = long[i] * P + s[i];
助记理解：用十进制类比 => 123
第一位是 1;
第二位是 1 * 10 + 2 = 12;
第三位是 前一位(12) * 进制(10) + 当前位数值(3) = 123

到这里字符串的前缀哈希都计算出来了，回到题目，如何计算ABCDEF，子串[4,5]的哈希值？
假设计算出来的字符串前缀哈希值h[0,22,33,44,56,67,78]
先给公式 => 子串 s[l,r] 的哈希值 = h[r] - h[l-1] * P^r-l+1
所以s[4,5] = h[5] - h[3] * P^2

s[l,r] = h[r] - h[l-1] * P^r-1+1;

我们先来看一个减法：
    ABCDEF
   -ABCD
   =    EF
如何才能使得这个等式成立？很简单，给被减数ABCD补两个0，即ABCD00,但是这两个0得如何补呢？自然是得按照进制P的指数倍进行扩大。
所以我们就能得到：
    ABCDEF
   -ABCD00
   =0000EF
所以得到公式：s[l,r] = h[r] - h[l-1] * P^r-1+1;


总结一下：

公式（1）：计算字符串s的前缀哈希值
h[i+1] = h[i] * P + s[i]

公式（2）：计算字符串s任意区间子串哈希值s[l,r]
s[l,r] = h[r] - h[l-1] * P ^ (r-l+1)

作用：比较两个字符串是否相等；一个字符串的两个子串也类似。

代码模板：








