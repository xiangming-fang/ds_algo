package indi.xm.jy.competition.oddweekcompetition.th92.sn4;

import org.junit.Test;

/**
 * t4 统计回文子序列数目
 */
public class Solution {


    // 算法原型：前缀和 + 后缀和
    // 灵神：https://leetcode.cn/problems/count-palindromic-subsequences/solutions/1993115/qian-hou-zhui-fen-jie-o100-chang-shu-kon-51cv/

    // 整理思路：
    // 1、我们可以通过枚举回文字符串的中间那个字符来找。

    // 2、举例：xxxxxxxyyyyyy1YYYYYXXXXX，其中x，y，X，Y表示（0-9的数字）
    // 此时我们需要找到以数字1为回文串的中间位置的回文子序列个数，那么应该怎么做呢？
    // 首先，因为题目已经限制了回文子序列的长度为5，然后中间位置我们也确定了，所以我们就是要找剩下的4位数字，我们又可以知道剩下的4位数字在中间位置的左边存在两个、右边也存在两个
    // 即，我们需要在1的左边所有字符：xxxxxxxyyyyyy 找到两位字符；右边所有字符：YYYYYXXXXX 找到两位字符。
    // 题目中给的所有字符都是在0-9中，所以两位字符的组合可能就是 00-99 共计100种。
    // 假设1的左边出现 00 - 100次，12 - 10次；1的右边出现 00 - 5次，21 - 3次
    // 那么我们的计算答案是：100 * 5 + 10 * 3 = 530。
    // 所以我们的大体思路是：枚举当前位置左边、右边所有字符2位数组成的次数，用左边次数乘以右边次数就是我们要的答案了。
    // 这样我们就可以得到当前位置能构成长度为5的回文子序列了。

    // 3、上一步已经分析出做法了，关键在于我们应该如何快速知道每个位置的左边、右边两位数组合出现的次数呢？
    // 举个例子：103301
    // 我们从后往前进行枚举，求出以 每个位置为起始字符 的两位字符组合。
    // 3.1 迭代的时候，我们可以用一个数组记录一下 当前位置右边 对应数字出现的次数 => suf1[10]
    // 3.2 同时，我们也可以用二维数组进行记录每个组合出现的个数 => suf2[10][10]
    // 初始时，suf1、suf2里面存储的都是0。
    // 那么关键点是如何维护suf1以及suf2这两个数组。
    // 其中suf1很好理解，碰见什么字符，就把对应下标位置元素加1.
    // 那么suf2呢？
    // 假设当前遍历到的字符是x,x范围是（0-9），首先我们可以知道要修改的suf2肯定是suf2[x][]。
    // 那么在suf2[x][?] 问号处应该如何修改呢？
    // 问号处有10个值，分别是0-9，这是个位置都要进行修改的。
    // 我们要清楚suf2的语意：每个组合（00-99）出现的次数
    // 那么我当前位置x已经确认下来了，那么另外一个值肯定是x右侧的所有字符，我们可以依次迭代x右侧字符，将出现的组合对应位置suf2[x][?] + 1;
    // 为了快速得到这个答案，就需要用到我们的数组：suf1（当前位置右边所有字符出现的次数）
    // 所以我们可以用： suf2[x][?] + suf1[?]
    // 从后往前遍历，遍历结束得到完整的suf2和suf1。

    // 4、我们需要从前往后遍历给定字符s
    // 我们依然要维护pre1和pre2，但是这里我们并不是先直接维护结束的，而是要在维护的过程中累加答案。
    // pre1和pre2的维护同suf1和suf2。
    // 第四步的关键是如何在维护的过程中累加答案？
    // 我们可以发现第三步我们维护的suf2并不是针对每个s位置维护的，而是针对s这个字符串进行维护的。
    // 所以我们并不能直接用suf2，因为此时suf2表示的是从字符 0 - n-1的所有组合出现次数，但是我们要的是当前位置右边的所有组合出现次数
    // 所以我们需要减去当前字符对suf2进行的增加？假设当前位置字符为x
    // suf1[x] --
    // suf2[x][?] - suf1[?]
    // 以上两步刚好和第三步维护的反过来,
    // 因为我们维护了pre2。
    // 所以最后答案：ans += suf2[i][j] * pre2[i][j]

    // 灵神这种做法的优点：
    // 1、空间复杂度太优美了，不用给每个位置开一个二维数组记录，剩下了很多空间

    // 不好的地方：
    // 1、suf2不好理解，特别是在维护pre2时候suf2的恢复。

    public int countPalindromes(String s) {
        int mod = (int)1e9 + 7;
        int n = s.length();
        int[] suf1 = new int[10];
        int[][] suf2 = new int[10][10];
        int[] pre1 = new int[10];
        int[][] pre2 = new int[10][10];
        int d;
        // 1、维护后缀数组suf2
        for (int i = n - 1; i >= 0; i--) {
            d = s.charAt(i) - '0';
            for (int j = 0; j < 10; j++) {
                suf2[d][j] += suf1[j];
            }
            suf1[d]++;
        }
        // 2、在维护前缀数组pre2时维护答案ans
        long ans = 0;
        for (int i = 0; i < n; i++) {
            d = s.charAt(i) - '0';

            // 3、suf2 恢复成保存 当前位置右边第一个元素的所有组合
            suf1[d] --;
            for (int j = 0; j < 10; j++) {
                suf2[d][j] -= suf1[j];
            }

            // 4、累加答案
            for (int l = 0; l < 10; l++) {
                for (int r = 0; r < 10; r++) {
                    // 语义别搞错了：注意两个都是 先l后r
                    ans += (long) pre2[l][r] * suf2[l][r];
                }
            }

            // 5、维护pre2
            for (int j = 0; j < 10; j++) {
                pre2[d][j] += pre1[j];
            }
            pre1[d]++;
        }
        return (int)(ans % mod);
    }

    @Test
    public void test(){
        System.out.println(countPalindromes("103301"));
    }

}
